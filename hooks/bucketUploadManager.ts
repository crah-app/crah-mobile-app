import { Platform } from 'react-native';
import * as FileSystem from 'expo-file-system';
import { AudioFile, sourceMetadataInterface, VideoMeta } from '@/types';
import { getMIMEType } from '@/utils/globalFuncs';
import { useAuth } from '@clerk/clerk-expo';
import axios from 'axios';
import { PhotoFile, VideoFile } from 'react-native-vision-camera';
import { Dispatch, SetStateAction } from 'react';

export async function uploadSource(
	source: VideoFile | PhotoFile | AudioFile, // in case of a photo, video or audio file
	extra_source: PhotoFile | null = null, // usually for a video post cover
	clerkToken: string,
	userId: string,
	setLoadingSourceProgress: Dispatch<SetStateAction<number>>,
	setError: Dispatch<SetStateAction<boolean>>,
	extra_metadata?: sourceMetadataInterface, // additional metadata to "source". Do not confuse with "extra_source"
) {
	console.log(extra_source);

	return new Promise(async (res, rej) => {
		try {
			const fileUri = source.path;
			const fileName = fileUri.split('/').pop();

			let extraSourceFileUri = extra_source?.path;
			let extraSourceFileName = extraSourceFileUri?.split('/').pop();

			const token = clerkToken;

			// 1. server request sending video meta-data via body
			const response = await fetch(
				'http://192.168.0.136:4000/api/source/create-upload',
				{
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						Authorization: `Bearer ${token}`,
						mode: 'cors',
					},
					body: JSON.stringify({
						userId,
						filename: fileName,
						duration: 'duration' in source ? source.duration : 0,
						height: source.height,
						width: source.width,
						contentType: getMIMEType(fileName as string),

						// extra source meta data
						extra_source: extra_source,
						extra_source_filename: extraSourceFileName,
						extra_source_content_type: getMIMEType(
							extraSourceFileName as string,
						),
					}),
				},
			);

			if (!response.ok)
				throw new Error('server could not prepare a source upload');

			const { url, videoId, key, extra_source_data } = await response.json();

			const fileLocation = fileUri.includes('file://')
				? fileUri
				: `file://${fileUri}`;
			const extraSourceFileLocation = extraSourceFileUri?.includes('file://')
				? extraSourceFileUri
				: `file://${extraSourceFileUri}`;

			console.log(
				'source url generated by server:',
				url,
				extra_source_data.url,
			);

			// 2. get file from Blob / ArrayBuffer
			const fileData = await FileSystem.readAsStringAsync(fileLocation, {
				encoding: FileSystem.EncodingType.Base64,
			});
			const binary = atob(fileData);
			const len = binary.length;
			const bytes = new Uint8Array(len);
			for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);

			// 3. XMLHttpRequest Upload
			await XHRUpload(
				url,
				fileName as string,
				key,
				extra_source_data.key,
				videoId,
				setLoadingSourceProgress,
				setError,
				bytes,
				extra_metadata,
			);

			// for extra source data: create file from Blob / ArrayBuffer and upload via XHR
			if (extra_source_data) {
				const extraFileData = await FileSystem.readAsStringAsync(
					extraSourceFileLocation,
					{
						encoding: FileSystem.EncodingType.Base64,
					},
				);
				const extraBinary = atob(extraFileData);
				const extraLen = extraBinary.length;
				const extraBytes = new Uint8Array(extraLen);
				for (let j = 0; j < extraLen; j++)
					extraBytes[j] = extraBinary.charCodeAt(j);

				await XHRUpload(
					extra_source_data.url,
					extraSourceFileName as string,
					extra_source_data.key,
					undefined,
					extra_source_data.id,
					setLoadingSourceProgress,
					setError,
					extraBytes,
				);

				res(true);
				console.log('✅ Uploading process complete');
			}

			res(true);
			console.log('✅ Uploading process complete');
		} catch (error) {
			console.error('❌ Error during uploading process:', error);
			setError(true);
			rej(false);
		}
	});
}

const XHRUpload = async (
	url: string,
	fileName: string,
	key: string,
	extra_file_key: string | undefined = undefined, // source key of the extra file
	sourceId: string,
	setLoadingSourceProgress: Dispatch<SetStateAction<number>>,
	setError: Dispatch<SetStateAction<boolean>>,
	bytes: Uint8Array<ArrayBuffer>,
	extra_metadata: sourceMetadataInterface | undefined = undefined,
) => {
	return new Promise((res, rej) => {
		const xhr = new XMLHttpRequest();

		xhr.open('PUT', url);

		xhr.setRequestHeader('Content-Type', getMIMEType(fileName));

		xhr.upload.onprogress = (e) => {
			if (e.lengthComputable) {
				let percent = (e.loaded / e.total) * 100;

				console.log(`Upload progress: ${percent.toFixed(2)}%`);
				setLoadingSourceProgress(Number(percent.toFixed(2)));
			}
		};

		xhr.onload = async () => {
			if (xhr.status === 200 || xhr.status === 204) {
				console.log('✅ source uploaded successfully!');
				console.log(url);

				try {
					const result = await axios.post(
						'http://192.168.0.136:4000/api/source/mark-source-as-uploaded',
						{
							sourceId,
							metadata: extra_metadata,
							key,
							extra_file_key,
						},
					);

					console.log('lel', result);
					res(`https://pub-78edb5b6f0d946d28db91b59ddf775af.r2.dev/${key}`);
				} catch (markErr) {
					console.warn('Source uploaded, but marking failed:', markErr);
					rej(
						new Error(
							`'Uploaded, but could not mark as uploaded' ${xhr.status}`,
						),
					);
				}
			} else {
				setError(true);
				console.error('❌ Error uploading video:', xhr.statusText);
				rej(new Error(`Upload failed with status ${xhr.status}`));
			}
		};

		xhr.onerror = (e) => {
			console.error('❌ A network error occured uploading video', e);
			setError(true);
			rej(new Error('Network error during upload'));
		};

		xhr.send(bytes.buffer); // send video as array-buffer
	});
};
